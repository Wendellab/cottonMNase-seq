# diffACRs_csaw_AD1ref.r

# csaw workflow for ACR differential accessibility (DA) analysis of allopolyploidization
# Guanjing Hu
# huguanjing@gmail.com
# https://wendellab.github.io/cottonMNase-seq

# module load py-deeptools r/3.5.0-py2-ufvuwmm bedtools2
# cd /work/LAS/jfw-lab/hugj2006/cottonLeaf
# R
options(scipen=999)
library(csaw)
library(edgeR)
library(ggplot2)

# wrapper
mergeResults =function (ranges, tab, tol, get.best = TRUE, merge.args = list(),
    combine.args = list(), best.args = list())
{
    merged <- do.call(mergeWindows, c(list(ranges, tol = tol), merge.args))
    combined <- do.call(combineTests, c(list(merged$id, tab), combine.args))
    output <- DataFrame(regions = I(merged$region), combined = I(combined))
    if (get.best) {
        output$best <- do.call(getBestTest, c(list(merged$id,tab), best.args))
    }
    metadata(output)$id <- merged$id
    output
}
overlapResults = function (ranges, tab, regions, get.best = TRUE, overlap.args = list(),    combine.args = list(), best.args = list())
{
    olap <- do.call(findOverlaps, c(list(query = regions, subject = ranges),
        overlap.args))
    combined <- do.call(combineOverlaps, c(list(olap, tab), combine.args))
    output <- DataFrame(regions = I(regions), combined = I(combined))
    if (get.best) {
        output$best <- do.call(getBestOverlaps, c(list(olap,tab), best.args))
    }
    metadata(output)$overlaps <- olap
    output
}
# merged <- mergeResults(filtered.data, resDi$table, tol=100, merge.args=list(max.width=5000))
sumTab<-function(res1,res2,res3,med="")
{
    s1<-summary(decideTests(res1)) # FDR <0.05
    s2<-summary(decideTests(res2)) # FDR <0.05
    s3<-summary(decideTests(res3))
    tbl<-as.data.frame(cbind(s1,s2,s3))
    tbl$med<-med
    return(tbl)
}
# generate MA plots
plotRes<-function(resDi,resF,resM,resHr,resPr,n=10000,out="out.pdf"){
    require("ggplot2")
    require("gridExtra")
    resDi$table$sig = factor(decideTests(resDi), levels=c(-1,0,1))
    resF$table$sig  = factor(decideTests(resF),levels=c(-1,0,1))
    resM$table$sig  = factor(decideTests(resM),levels=c(-1,0,1))
    resHr$table$sig  = factor(decideTests(resHr),levels=c(-1,0,1))
    resPr$table$sig  = factor(decideTests(resPr),levels=c(-1,0,1))
    select = sample(1:nrow(resDi$table),n)
    cvalue<-c("red","black","red");names(cvalue)=c(-1,0,1)
    pdf(out)
    p1<-ggplot(data=data.frame(resDi$table[select,]), aes(x = logCPM, y = logFC, col = sig)) + geom_point() + scale_color_manual(values =cvalue[levels(droplevels(resDi$table[select,]$sig))]) + geom_smooth(inherit.aes=F, aes(x = logCPM, y = logFC), method = "loess") + geom_hline(yintercept = 0) + labs(col = NULL) + theme_bw()+ theme(legend.position = "none")
    p2<-ggplot(data=data.frame(resF$table[select,]), aes(x = logCPM, y = logFC, col = sig)) + geom_point() + scale_color_manual(values =cvalue[levels(droplevels(resF$table[select,]$sig))]) + geom_smooth(inherit.aes=F, aes(x = logCPM, y = logFC), method = "loess") + geom_hline(yintercept = 0) + labs(col = NULL) + theme_bw()+ theme(legend.position = "none")
    p3<-ggplot(data=data.frame(resM$table[select,]), aes(x = logCPM, y = logFC, col = sig)) + geom_point() + scale_color_manual(values =cvalue[levels(droplevels(resM$table[select,]$sig))]) + geom_smooth(inherit.aes=F, aes(x = logCPM, y = logFC), method = "loess") + geom_hline(yintercept = 0) + labs(col = NULL) + theme_bw()+ theme(legend.position = "none")
    p4<-ggplot(data=data.frame(resHr$table[select,]), aes(x = logCPM, y = logFC, col = sig)) + geom_point() + scale_color_manual(values =cvalue[levels(droplevels(resHr$table[select,]$sig))]) + geom_smooth(inherit.aes=F, aes(x = logCPM, y = logFC), method = "loess") + geom_hline(yintercept = 0) + labs(col = NULL) + theme_bw()+ theme(legend.position = "none")
    p5<-ggplot(data=data.frame(resPr$table[select,]), aes(x = logCPM, y = logFC, col = sig)) + geom_point() + scale_color_manual(values =cvalue[levels(droplevels(resPr$table[select,]$sig))]) + geom_smooth(inherit.aes=F, aes(x = logCPM, y = logFC), method = "loess") + geom_hline(yintercept = 0) + labs(col = NULL) + theme_bw()+ theme(legend.position = "none")
    grid.arrange(p1, p2, p3, p4,p5,ncol = 3, nrow = 3)
    dev.off()
}
########

# The input BAM files were generated by mapping all MNase-seq reads against the AD1 reference genome, properly paired restricted, mapping quality filtered, and sorted using script "runHisat2.sh".

#######################
## Convert BAM to BW ##
#######################
# sbatch runSh.slurm

###################################
## From sorted bam to DB results ##
###################################
setwd("/work/LAS/jfw-lab/hugj2006/cottonLeaf/Qregulation_diffACRs/AD1ref")

# specify paired-end BAMs from F1 and AD1
bam.files=grep("A6H_",list.files("mapping",patter="sort.bam$",full.names=T),invert=T,value=T)
# bam.files=grep("F|M",list.files("mapping",patter="sort.bam$",full.names=T),value=T)
df=data.frame(BAM=bam.files, genome=substring(bam.files,8+1,8+1),digestion=substring(bam.files,8+3,8+3))
df

# input identified ACRs
load("../../Qregulation3/ACRsC.rdata")->l;l
# test whether to seperately analyze subgenomes or together
peaks=list(A = ACR.AD1a, D=ACR.AD1d)

# separate A and D subgenomes for analysis
for(g in c("D","A"))
{
   ## 1. input sorted and indexed bam files
   use = df[df$genome=="F"|df$genome=="M"|df$genome==g,]
   use.chr <- c(paste0(g,"0", 1:9), paste0(g,10:13))
   print(use)
   print(use.chr)
   bams=as.character(use$BAM)
   # minimal MAPQ quality 20, paired-end
   param <- readParam(pe="both", restrict=use.chr);param
   
   ## 2.1. Count reads into ACRs
   peak.counts <- regionCounts(bams, peaks[[g]], param=param)
   # filter low abundance peaks
   peak.abundances <- aveLogCPM(asDGEList(peak.counts))
   # ......only use peaks logCPM > -3; few or no peaks should be removed; modify as desired
   keep <- peak.abundances > -3
   summary(keep)
   peak.counts.filt <- peak.counts[keep, ]
   
   ## 2.2. Count reads into 150 bp windows, based on fragment size
   win.data <- windowCounts(bams, ext=150, width=150, param=param)
   win.data
   head(assay(win.data))
   # Filtering out uninteresting regions.
   # simple restriction to filter window abundances at 5% lowe end
   abundances <- aveLogCPM(asDGEList(win.data))
   summary(abundances)
   keep.simple <- abundances > quantile(abundances,0.05)
   summary(keep.simple)
   # remove low variance
   logcounts <- cpm(asDGEList(win.data), log=TRUE)
   vars <- apply(logcounts, 1, var)
   keep.var <- vars > quantile(vars,0.25)
   summary(keep.var)
   # global enrichment to keep windows at least 1.5 fold of background signal
   bin.size <- 2000L
   binned <- windowCounts(bams, bin=TRUE, width=bin.size, param=param)
   filter.stat <- filterWindows(win.data, binned, type="global")
   min.fc=1.5
   pdf(paste0("checkBackground_",g,".pdf"))
   hist(filter.stat$back.abundances, xlab="Adjusted bin log-CPM", breaks=100, main="", col="grey80", xlim=c(min(filter.stat$back.abundances), 0))
   global.bg <- filter.stat$abundances - filter.stat$filter
   abline(v=global.bg[1], col="red", lwd=2)
   abline(v=global.bg[1]+log2(min.fc), col="blue", lwd=2)
   legend("topright", lwd=2, col=c('red', 'blue'),legend=c("Background", "Threshold"))
   dev.off()
   keep <- filter.stat$filter > log2(min.fc)
   summary(keep) # two stringent, losing too many data, not suitable for DNS-MNase-seq
   # filter used
   summary(keep.simple&keep.var)
   counts.local.filt <- win.data[keep.simple&keep.var,]
   
   ## 3. Calculating normalization factors.
   #  count BAM background bins (for TMM normalization)
   binned <- windowCounts(bams, bin=TRUE, width=10000, param=param)
   # --------------NORMALIZATION--------------------
   # method 1: ACR peaks only, TMM normalization based on binned counts
   peak.counts.tmm <- peak.counts.filt
   peak.counts.tmm <- normFactors(binned, se.out=peak.counts.tmm)
   # method 2: ACR peaks only, csaw loess-normalization
   peak.counts.loess <- peak.counts.filt
   peak.counts.loess <- normOffsets(peak.counts.loess, type="loess", se.out=TRUE)
   # from vignette: "For type="loess", a numeric matrix of the same dimensions as counts, containing the log-based offsets for use in GLM fitting.
   # method 3: csaw de novo peaks by local enrichment, TMM normalization based on binned counts
   counts.local.tmm <- counts.local.filt
   counts.local.tmm <- normFactors(binned, se.out=counts.local.tmm)
   # method 4: csaw de novo peaks by local enrichment, csaw loess-normalization
   counts.local.loess <- counts.local.filt
   counts.local.loess <- normOffsets(counts.local.loess, type="loess", se.out=TRUE)
   # from vignette: "For type="loess", a numeric matrix of the same dimensions as counts, containing the log-based offsets for use in GLM fitting."
   # --------------NORMALIZATION--------------------
   save(list=c("peak.counts.tmm","peak.counts.loess","counts.local.tmm","counts.local.loess"), file=paste0("DAnorm_",g,".rdata"))
   
   ## 4. DA analysis with 4 different methods
   for(med in c("peak.counts.tmm","peak.counts.loess","counts.local.tmm","counts.local.loess"))
   {
       # set working windows for the desired analysis
       working.windows <- get(med)
       y <- asDGEList(working.windows)
       sample<-gsub("_.*","",use$BAM)
       colnames(y$counts) <- sample
       rownames(y$samples) <- sample
       use$genome=gsub("A|D","P",use$genome)
       y$samples$group <- factor(paste0(use$genome,use$digestion))
       # setup design matrix; see edgeR manual for more information
       design <- model.matrix(~0+group, data=y$sample)
       # stabilize dispersion estimates with empirical bayes
       y <- estimateDisp(y, design)
       fit <- glmQLFit(y, design, robust=TRUE)
         # Estimate dispersion, plot e coefficient of biological variation (BCV) and quasi-likelihood (QL)dispersion
         # pdf(paste0("Dispersion_",g,".pdf"))
         # plotBCV(y)
         # plotQLDisp(fit)
         # dev.off()
       
       # DA analyses
       resDi <- glmQLFTest(fit, contrast=makeContrasts(groupPL-groupPH,levels=design))
       resF  <- glmQLFTest(fit, contrast=makeContrasts(groupFL-groupFH,levels=design))
       resM  <- glmQLFTest(fit, contrast=makeContrasts(groupML-groupMH,levels=design))
       resHr  <- glmQLFTest(fit, contrast=makeContrasts((groupFL-groupFH)-(groupPL-groupPH),levels=design))
       resPr  <- glmQLFTest(fit, contrast=makeContrasts((groupML-groupMH)-(groupFL-groupFH),levels=design))
       
       # MA plots and summary table
       # summary(decideTests(resDi)) # FDR <0.05
       tbl<-as.data.frame(cbind( summary(decideTests(resDi)), summary(decideTests(resF)), summary(decideTests(resM)), summary(decideTests(resHr)), summary(decideTests(resPr)) ))
       tbl$med<-med
       tbl$genome=g
       write.table(tbl,file=paste0("sigTable.",g,".",med,".txt"),sep="\t")
       plotRes(resDi,resF,resM,resHr,resPr,out=paste0("plotMA.",g,".",med,".pdf"))
       
       # for method 3 and 4, recalculate FDR by ACRs
       if(grepl("^counts",med))
       {
           for(i in c("resDi","resF","resM","resHr","resPr"))
           {
               print(i)
               res=get(i)
               olap <- overlapResults(working.windows, regions=peaks[[g]], tab=res$table)
               cx<-as.data.frame(table(olap$combined$direction,olap$combined$FDR<0.05))
               names(cx)<-c("direction","sig","number")
               cx$med<-med
               print(cx)
               cx$res<-i
               if(i=="resDi"){acx<-cx}else{acx<-rbind(acx,cx)}
               assign(i,olap)
           }
           write.table(acx,file=paste0("sigTable2.",g,".",med,".txt"),row.names=FALSE,sep="\t")
       }
      
      # save
       save(resDi,resF,resM,resHr,resPr, working.windows, file=paste0("DAres_",g,".",med,".rdata"))
    }
}
  

##########################################
## Compare DB results by 4 norm methods ##
##########################################
# put 4 method results together to inspect
library(reshape2)
fl<-list.files(pattern="sigTable[.].*peak")
for(f in fl){
    x<-read.table(f,header=T, sep="\t")
    y<-cbind(c("down","up"), x[c("Down","Up"),])
    names(y)=c("direction","P","F","M","Hr","Pr","med","genome")
    if(f==fl[1]){res<-y}else{res<-rbind(res,y)}
}
fl<-list.files(pattern="sigTable2")
for(f in fl){
    acx<-read.table(f,header=T, sep="\t")
    ss=dcast(acx,direction+sig+med~res,value.var="number")
    ss[is.na(ss)]=0
    #ss=cbind(acx[acx$res=="resDi",1:3],acx[acx$res=="resF",3],acx[acx$res=="resH",3:4])
    sss=ss[ss$sig&ss$direction!="mixed",c("direction","resDi","resF","resM","resHr","resPr","med")]
    sss$genome=unlist(strsplit(f,"[.]"))[2]
    names(sss)=c("direction","P","F","M","Hr","Pr","med","genome")
    res<-rbind(res,sss)
}

# Observed_up/ Expected_up
load("../../Qregulation3/ACRsC.rdata")->l;l;ACR.A2
exp=c(length(ACR.AD1a),length(ACR.AD1d))
names(exp)=c("A","D")
exp
#      A      D
#    260278 189068
res$expM=exp[as.character(res$genome)]
res$Pperc=res$P/res$expM
res$Fperc=res$F/res$expM
res$Mperc=res$M/res$expM
write.table(res, file="methodComp.AD1ref.txt",row.names=FALSE,sep="\t")

library(ggplot2)
library("gridExtra")
x<-read.table("methodComp.AD1ref.txt",head=T,sep="\t")
ss<- theme_bw()+ theme(legend.position = "none")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1))
p1<-ggplot(data=x,aes(x=med,y=P,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
p2<-ggplot(data=x,aes(x=med,y=F,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
p3<-ggplot(data=x,aes(x=med,y=M,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
p4<-ggplot(data=x,aes(x=med,y=Hr,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
p5<-ggplot(data=x,aes(x=med,y=Pr,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
p6<-ggplot(data=x,aes(x=med,y=Fperc,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
p7<-ggplot(data=x,aes(x=med,y=Pperc,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
p8<-ggplot(data=x,aes(x=med,y=Mperc,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
pdf("methodComp.AD1ref.pdf")
p1
p2
p3
grid.arrange(p1+ss, p2+ss, p3+ss, ncol = 3, nrow = 1)
p4
p5
grid.arrange(p4+ss, p5+ss, ncol = 3, nrow = 1)
p6
p7
p8
grid.arrange(p6+ss, p7+ss, p8+ss, ncol = 3, nrow = 1)
dev.off()
# based on p1~p3,  counts.local.tmm > counts.local.loess > peak.counts.tmm >> peak.counts.loess in finding ACRs
# Hr: all methods agree on that few changes (<30 ACRs) by hybridization, somehow more in D than A genome; more decrease then increase in accessbility

###########################################################
## De novo DA windows analysis: genome-wide and promoter ##
###########################################################
options(scipen=999)
library(csaw)
library(edgeR)
library(ggplot2)
library(GenomicFeatures)

setwd("/work/LAS/jfw-lab/hugj2006/cottonLeaf/Qregulation_diffACRs/AD1ref")

# specify paired-end BAMs from F1 and AD1
bam.files=grep("A6H_",list.files("mapping",patter="sort.bam$",full.names=T),invert=T,value=T)
# bam.files=grep("F|M",list.files("mapping",patter="sort.bam$",full.names=T),value=T)
df=data.frame(BAM=bam.files, genome=substring(bam.files,8+1,8+1),digestion=substring(bam.files,8+3,8+3))
df

# input identified ACRs
load("../../Qregulation3/ACRsC.rdata")->l;l
# test whether to seperately analyze subgenomes or together
peaks=list(A = ACR.AD1a, D=ACR.AD1d)

### import genome annotation
txdb <- loadDb("../../refGenomes/txdb.AD1utx.sqlite")
# Gene region
gns= genes(txdb)
gns= gns[grep("scaffold|Contig",seqnames(gns),invert=T)]# 118590
quantile(width(gns))
gns.a = gns[grepl("A",seqnames(gns)),]
gns.d = gns[grepl("D",seqnames(gns)),]
gns=list(A=gns.a,D=gns.d)
# input promoters: 300bb upstream of TSS
pms = promoters(txdb, upstream=300, downstream=0) # 120545
pms= pms[grep("scaffold|Contig",seqnames(pms),invert=T)]# 118590
pms.a = pms[grepl("A",seqnames(pms))&grepl("[.]1$",names(pms)),]
pms.d = pms[grepl("D",seqnames(pms))&grepl("[.]1$",names(pms)),]
pms300=list(A=pms.a,D=pms.d)
# input promoters: 1kb upstream of TSS
pms= pms[grep("scaffold|Contig",seqnames(pms),invert=T)]# 118590
pms.a = pms[grepl("A",seqnames(pms))&grepl("[.]1$",names(pms)),]
pms.d = pms[grepl("D",seqnames(pms))&grepl("[.]1$",names(pms)),]
pms1k=list(A=pms.a,D=pms.d)
# input promoters: 2kb upstream of TSS
pms= pms[grep("scaffold|Contig",seqnames(pms),invert=T)]# 118590
pms.a = pms[grepl("A",seqnames(pms))&grepl("[.]1$",names(pms)),]
pms.d = pms[grepl("D",seqnames(pms))&grepl("[.]1$",names(pms)),]
pms2k=list(A=pms.a,D=pms.d)


# separate A and D subgenomes for counts.local.tmm analysis
for(g in c("A","D"))
{
    use = df[df$genome=="F"|df$genome=="M"|df$genome==g,]
    load( paste0("DAnorm_",g,".rdata") )

    # set working windows for the desired analysis
    med="counts.local.tmm"
    working.windows <- get(med)
    y <- asDGEList(working.windows)
    sample<-gsub("_.*","",use$BAM)
    colnames(y$counts) <- sample
    rownames(y$samples) <- sample
    use$genome=gsub("A|D","P",use$genome)
    y$samples$group <- factor(paste0(use$genome,use$digestion))
    # setup design matrix; see edgeR manual for more information
    design <- model.matrix(~0+group, data=y$sample)
    # stabilize dispersion estimates with empirical bayes
    y <- estimateDisp(y, design)
    fit <- glmQLFit(y, design, robust=TRUE)
      # Estimate dispersion, plot e coefficient of biological variation (BCV) and quasi-likelihood (QL)dispersion
      # pdf(paste0("Dispersion_",g,".pdf"))
      # plotBCV(y)
      # plotQLDisp(fit)
      # dev.off()
    
    # DA analyses
    resDi <- glmQLFTest(fit, contrast=makeContrasts(groupPL-groupPH,levels=design))
    resF  <- glmQLFTest(fit, contrast=makeContrasts(groupFL-groupFH,levels=design))
    resM  <- glmQLFTest(fit, contrast=makeContrasts(groupML-groupMH,levels=design))
    resHr  <- glmQLFTest(fit, contrast=makeContrasts((groupFL-groupFH)-(groupPL-groupPH),levels=design))
    resPr  <- glmQLFTest(fit, contrast=makeContrasts((groupML-groupMH)-(groupFL-groupFH),levels=design))
    #  save
    save(working.windows,resDi,resF,resM,resHr,resPr, file=paste0("res_",g,".",med,".rdata"))
}

# Examine results
sigRes=function(res, label=NULL){
    require(reshape2)
    names(res) # "regions"  "combined" "best"
    res0=data.frame(Var1=c("sigN","sigBp","sigN","sigBp"),Var2=c("up","up","down","down"),value=0)
    # combined results
    sig=which(res$combined$FDR<0.05)
    if(length(sig)>0){
        sigN=tapply(width(res$regions[sig]),res$combined$direction[sig], FUN=length)
        sigBp=tapply(width(res$regions[sig]),res$combined$direction[sig], FUN=sum)
        Cres=melt(rbind(sigN,sigBp))
    }else{ Cres= res0}
    Cres$FDR="combined"
    # best results
    sig=which(res$best$FDR<0.05)
    if(length(sig)>0){
        res$best$direction = ifelse(res$best$logFC>0, "up","down")
        sigN=tapply(width(res$regions[sig]),res$best$direction[sig], FUN=length)
        sigBp=tapply(width(res$regions[sig]),res$best$direction[sig], FUN=sum)
        Bres=melt(rbind(sigN,sigBp))
    }else{ Bres= res0}
    Bres$FDR="best"
    lres=rbind(Cres,Bres)
    if(!is.na(label)){lres$label=label}
    return(lres)
}
for(g in c("A","D"))
{
    # get working windows for the desired analysis
    med="counts.local.tmm"
    load( paste0("res_",g,".",med,".rdata"))
    
    for(i in c("resDi","resF","resM","resHr","resPr"))
        {
            print(i)
            res=get(i)
            # merging windows, Correcting for multiple testing.
            merged <- mergeResults(working.windows, res$table, tol=200L)
            # overlap to ACRs, Correcting for multiple testing.
            olACR <- overlapResults(working.windows, tab=res$table, regions=peaks[[g]])
            # overlap to promoters, Correcting for multiple testing.
            olG <- overlapResults(working.windows, tab=res$table, regions=gns[[g]])
            olP300 <- overlapResults(working.windows, tab=res$table, regions=pms300[[g]])
            olP1k <- overlapResults(working.windows, tab=res$table, regions=pms1k[[g]])
            olP2k <- overlapResults(working.windows, tab=res$table, regions=pms2k[[g]])
            sr<-rbind(sigRes(merged,"SlidingW"), sigRes(olACR,"ACR"),sigRes(olG,"Gene"), sigRes(olP300,"Promoter300"), sigRes(olP1k,"Promoter1k"), sigRes(olP2k,"Promoter2k"))
            sr$test=i
            sr$genome=g
            print(sr)
            # print(sumRes)
            if(g=="A"&i=="resDi"){sumtbl=sr}else{sumtbl=rbind(sumtbl,sr)}
            #save(merged, olACR, olG, olP300,olP1k, olP2k, file=paste0(i,"_",g,".",med,".rdata"))
        }
}
write.table(sumtbl,file="resNnBp.AD1ref.txt",row.names=FALSE,sep="\t")
sumtbl

# plot effect
x<-read.table("resNnBp.AD1ref.txt",header=T,sep="\t")
library(ggplot2)
pdf("resNnBp.AD1ref.pdf")
ss<- theme_bw()+ theme(legend.position = "right")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1))
# resHr vs resPr, separate N and Bp.
ggplot(data=x[x$test%in%c("resHr","resPr")&x$Var1=="sigN",],aes(x=test,y=value,group=test,fill=Var2))+geom_bar(stat="identity")+ facet_grid(genome~label+FDR)+ss
ggplot(data=x[x$test%in%c("resHr","resPr")&x$Var1=="sigBp",],aes(x=test,y=value,group=test,fill=Var2))+geom_bar(stat="identity")+ facet_grid(genome~label+FDR)+ss
# resHr vs resPr, separate N and Bp.
ggplot(data=x[x$test%in%c("resHr","resPr")&x$Var1=="sigN"&x$label=="Promoter1k",], aes(x=test,y=value,group=test,fill=Var2))+geom_bar(stat="identity")+ facet_grid(FDR~genome)+ss
ggplot(data=x[x$test%in%c("resHr","resPr")&x$Var1=="sigBp"&x$label=="Promoter1k",], ,aes(x=test,y=value,group=test,fill=Var2))+geom_bar(stat="identity")+ facet_grid(FDR~genome)+ss

# resDi, F, M
ggplot(data=x[x$test%in%c("resDi","resF","resM")&x$Var1=="sigN",], aes(x=test,y=value,group=test,fill=Var2))+geom_bar(stat="identity")+ facet_grid(genome~label+FDR)+ss
ggplot(data=x[x$test%in%c("resDi","resF","resM")&x$Var1=="sigBp",], aes(x=test,y=value,group=test,fill=Var2))+geom_bar(stat="identity")+ facet_grid(genome~label+FDR)+ss
dev.off()
# CONCLUSION: 1.Pr > Hr increased accessibility for ACR, genome-wid, and 1kb promoter, what about gene body and other locations, eg. TE? 2. best and combined results are quite consistent

# --- ABANDON BELOW


#################################
## Compare DB results for MSFs ##
#################################
# wrapper
mergeResults =function (ranges, tab, tol, get.best = TRUE, merge.args = list(),
    combine.args = list(), best.args = list())
{
    merged <- do.call(mergeWindows, c(list(ranges, tol = tol), merge.args))
    combined <- do.call(combineTests, c(list(merged$id, tab), combine.args))
    output <- DataFrame(regions = I(merged$region), combined = I(combined))
    if (get.best) {
        output$best <- do.call(getBestTest, c(list(merged$id,tab), best.args))
    }
    metadata(output)$id <- merged$id
    output
}
overlapResults = function (ranges, tab, regions, get.best = TRUE, overlap.args = list(),    combine.args = list(), best.args = list())
{
    olap <- do.call(findOverlaps, c(list(query = regions, subject = ranges),
        overlap.args))
    combined <- do.call(combineOverlaps, c(list(olap, tab), combine.args))
    output <- DataFrame(regions = I(regions), combined = I(combined))
    if (get.best) {
        output$best <- do.call(getBestOverlaps, c(list(olap,tab), best.args))
        output$best$direction=ifelse(output$best$logFC>0, "up","down")
    }
    metadata(output)$overlaps <- olap
    output
}
# merged <- mergeResults(filtered.data, resDi$table, tol=100, merge.args=list(max.width=5000))

### how do DB results compare to iSeg MSFs? Quite Consistent
load("../../Qregulation3/ACRs_MSF.rdata")
# normalized by whole genome
MSF.AD1
# normalized by subgenome
AD1a=MSF.AD1a
seqlevels(AD1a) = gsub("^Chr","A",seqlevels(AD1a))
AD1d=MSF.AD1d
seqlevels(AD1d) = gsub("^Chr","D",seqlevels(AD1d))

#load("DBres.rdata")

#-----------------------------------
# resM vs MSF.AD1. high consistency with iSeg results expected; combined Stats is better than best stats
olap <- overlapResults(filtered.data, regions=MSF.AD1, tab=resM$table)
table(olap$combined$direction,olap$combined$FDR<0.05,substring(seqnames(olap$regions),1,1))
#, ,  = A
#        FALSE  TRUE
#  down     24     5
#  mixed    17     0
#  up     4460 82851
#, ,  = D
#        FALSE  TRUE
#  down      9     7
#  mixed     8     0
#  up     3336 64365
table(olap$best$direction,olap$best$FDR<0.05,substring(seqnames(olap$regions),1,1))
#, ,  = A
#       FALSE  TRUE
#  down    30     5
#  up    6108 81214
#, ,  = D
#       FALSE  TRUE
#  down    13     7
#  up    4505 63200
#-------------By subgenome -----------------
# resM vs AD1a high consistency expected
olap <- overlapResults(filtered.data, regions=AD1a, tab=resM$table)
Ma=olap$combined
table(olap$combined$direction,olap$combined$FDR<0.05)
#      FALSE  TRUE
#down     24     5
#mixed    20     0
#up     5930 91342
olap <- overlapResults(filtered.data, regions=AD1d, tab=resM$table)
Md=olap$combined
table(olap$combined$direction,olap$combined$FDR<0.05)
#      FALSE  TRUE
#down     10     7
#mixed     7     0
#up     2347 55970

#-----------------------------------
# resF vs MSF.AD1, lower consistency than above is expected given strong polyploidy effect
olap <- overlapResults(filtered.data, regions=MSF.AD1, tab=resF$table)
table(olap$combined$direction,olap$combined$FDR<0.05,substring(seqnames(olap$regions),1,1))
#, ,  = A
#        FALSE  TRUE
#  down   4478   111
#  mixed  7348     1
#  up    52365 23054
#, ,  = D
#        FALSE  TRUE
#  down   4639    53
#  mixed  8883     1
#  up    42030 12119
table(olap$best$direction,olap$best$FDR<0.05,substring(seqnames(olap$regions),1,1))
#, ,  = A
#       FALSE  TRUE
#  down  8637    84
#  up   58216 20420
#, ,  = D
#       FALSE  TRUE
#  down 10084    45
#  up   47148 10448
#---------- by Subgenome ----------
# resF vs MSF.AD1, low consistency expected given strong polyploidy effect
olap <- overlapResults(filtered.data, regions=AD1a, tab=resF$table)
Fa=olap$combined
table(olap$combined$direction,olap$combined$FDR<0.05)
#      FALSE  TRUE
#down   5121   132
#mixed  8325     1
#up    56489 27253
olap <- overlapResults(filtered.data, regions=AD1d, tab=resF$table)
Fd=olap$combined
table(olap$combined$direction,olap$combined$FDR<0.05)
#      FALSE  TRUE
#down   3907    43
#mixed  7582     0
#up    37575  9234

#-----------------------------------
# resP vs MSF.AD1, DB especially up (increased accessibility) expected if strong polyploidy effect
olap <- overlapResults(filtered.data, regions=MSF.AD1, tab=resP$table)
table(olap$combined$direction,olap$combined$FDR<0.05,substring(seqnames(olap$regions),1,1))
#, ,  = A
#        FALSE  TRUE
#  down  14518    21
#  mixed 21546     0
#  up    49864  1408
#, ,  = D
#        FALSE  TRUE
#  down  10588     5
#  mixed 15864     0
#  up    40736   532
table(olap$best$direction,olap$best$FDR<0.05,substring(seqnames(olap$regions),1,1))
#, ,  = A
#       FALSE  TRUE
#  down 24307    20
#  up   61709  1321
#, ,  = D
#       FALSE  TRUE
#  down 17922     5
#  up   49311   487
#-------------By Subgenome---------------
# resP vs MSF.AD1, many DB expected if strong polyploidy effect
olap <- overlapResults(filtered.data, regions=AD1a, tab=resP$table)
Pa=olap$combined
table(olap$combined$direction,olap$combined$FDR<0.05)
#      FALSE  TRUE
#down  16674    25
#mixed 24356     0
#up    54731  1535
olap <- overlapResults(filtered.data, regions=AD1d, tab=resP$table)
Pd=olap$combined
table(olap$combined$direction,olap$combined$FDR<0.05)
#      FALSE  TRUE
#down   8973     3
#mixed 13373     0
#up    35620   372

### assemble overlap results
olapA=DataFrame(regions = I(MSF.AD1a), M = I(Ma),F=I(Fa),P=I(Pa))
olapD=DataFrame(regions = I(MSF.AD1d), M = I(Md),F=I(Fd),P=I(Pd))

# combined results
df=data.frame(regions =c("DNS_AD1","DNS_F1","AD1-F1"),AsizeUp=NA,AnoUp=NA,AsizeDown=NA,AnoDown=NA,DsizeUp=NA,DnoUp=NA,DsizeDown=NA,DnoDown=NA)
rownames(df)=c("resM","resF","resP")
for(i in c("resM","resF","resP")){
    print(i)
    res=get(i)
    # keep p-value significant regions, combined, FDR<0.05, DB regions
    ff = (res$table$PValue<0.05)
    merged <- mergeResults(filtered.data[ff,], res$table[ff,], tol=100, merge.args=list(max.width=5000))
    gr = merged$regions[merged$combined$FDR<0.05,]
    mcols(gr) =cbind(mcols(gr),merged$combined[merged$combined$FDR<0.05,])
    
    df[i,"AsizeUp"] =sum(width(gr[gr$direction=="up"&grepl("A",seqnames(gr))]))/10^6
    df[i,"AnoUp"] =length(gr[gr$direction=="up"&grepl("A",seqnames(gr))])
    df[i,"AsizeDown"] =sum(width(gr[gr$direction=="down"&grepl("A",seqnames(gr))]))/10^6
    df[i,"AnoDown"] =length(gr[gr$direction=="down"&grepl("A",seqnames(gr))])
    
    df[i,"DsizeUp"] =sum(width(gr[gr$direction=="up"&grepl("D",seqnames(gr))]))/10^6
    df[i,"DnoUp"] =length(gr[gr$direction=="up"&grepl("D",seqnames(gr))])
    df[i,"DsizeDown"] =sum(width(gr[gr$direction=="down"&grepl("D",seqnames(gr))]))/10^6
    df[i,"DnoDown"] =length(gr[gr$direction=="down"&grepl("D",seqnames(gr))])

    assign(paste0("gr_",i),gr)
}
print(df)
#        regions   AsizeUp  AnoUp AsizeDown AnoDown   DsizeUp  DnoUp DsizeDown DnoDown
#resM    DNS_AD1 141.93611 362990   81.6787  309392 107.15700 262993  38.54740 149765
#resF     DNS_F1 133.16550 377260  122.0519  387152  78.33450 236019  52.35460 179272
#resP     AD1-F1  53.68396 229266   40.3131  183663  33.78205 143836  24.01915 109683
combined = list(M=gr_resM,F=gr_resF,P=gr_resP)
save(df,combined,olapA,olapD,file="DBres_out.rdata")

#########################
## Annotate DB results ##
#########################
load("DBres_out.rdata")
setwd("../../")
# annotateACRs function
source("FUN.acr.r")
# load chipseeker annotation results
library(ChIPseeker)
load("Qregulation3/MSFpg.rdata")->l;l # "anL" "df"
names(anL) # "A2"     "D5"     "F1a"    "F1d"    "F1.At"  "F1.Dt"  "AD1a"   "AD1d" "AD1.At" "AD1.Dt
# check correspondance, TRUE
table(ranges(anL$AD1a@anno) ==ranges(olapA$regions[olapA$an$type!="Distal"]))
table(ranges(anL$AD1d@anno) ==ranges(olapD$regions[olapD$an$type!="Distal"]))


## import genome annotation
txdb <- loadDb("refGenomes/txdb.AD1utx.sqlite")
gns= genes(txdb)
gns.AD1= gns[grep("scaffold",seqnames(gns),invert=T)]# 74902
gns.AD1a = gns.AD1[grep("A",seqnames(gns.AD1)),]; seqlevels(gns.AD1a)=gsub("A","Chr",seqlevels(gns.AD1a))
gns.AD1d = gns.AD1[grep("D",seqnames(gns.AD1)),]; seqlevels(gns.AD1d)=gsub("D","Chr",seqlevels(gns.AD1d));

## check DB with annotation
olap=olapA; gns=gns.AD1a; fine = anL$AD1a@anno
an= annotateACRs(olap$regions,gns, distance=2000)
an$fine="-"
an$fine[an$type!="Distal"] = fine$annotation2
olap$an = I(an[,12:20])
olapA=olap
with(olap,table(an$type,P$direction, P$FDR<0.05))
#, ,  = FALSE
#            down mixed    up
#  Distal   13049 18317 40886
#  Genic      751  1539  4139
#  Proximal  2874  4500  9706
#, ,  = TRUE
#            down mixed    up
#  Distal      20     0  1237
#  Genic        2     0   104
#  Proximal     3     0   194
with(olap,table(an$fine,P$direction, P$FDR<0.05))
#, ,  = FALSE
#                      down mixed    up
#  -                  13049 18317 40886
#  Distal Intergenic    509   756  1420
#  Downstream (<1kb)     53    95   138
#  Downstream (1-2kb)    31    48    76
#  Downstream (2-3kb)    18    18    52
#  Exon                 102   238   504
#  Intron               123   199   443
#  Promoter (<=1kb)    1420  2523  6618
#  Promoter (1-2kb)     921  1452  3131
#  Promoter (2-3kb)     448   710  1463
#, ,  = TRUE
#                       down mixed    up
#  -                     20     0  1237
#  Distal Intergenic      0     0    32
#  Downstream (<1kb)      0     0     1
#  Downstream (1-2kb)     0     0     1
#  Downstream (2-3kb)     0     0     3
#  Exon                   0     0     4
#  Intron                 0     0     6
#  Promoter (<=1kb)       4     0   183
#  Promoter (1-2kb)       1     0    50
#  Promoter (2-3kb)       0     0    18

#---------------------------------------------------
olap=olapD; gns=gns.AD1d; fine = anL$AD1d@anno
an= annotateACRs(olap$regions,gns, distance=2000)
an$fine="-"
an$fine[an$type!="Distal"] = fine$annotation2
olap$an = I(an[,12:20])
olapD=olap
with(olap,table(an$type,P$direction, P$FDR<0.05))
#, ,  = FALSE
#            down mixed    up
#  Distal    6504  9337 24557
#  Genic      526  1063  3125
#  Proximal  1943  2973  7938
#, ,  = TRUE
#            down mixed    up
#  Distal       3     0   270
#  Genic        0     0    31
#  Proximal     0     0    71
with(olap,table(an$fine,P$direction, P$FDR<0.05))
#, ,  = FALSE
#                      down mixed    up
#  -                   6504  9337 24557
#  Distal Intergenic    332   423  1040
#  Downstream (<1kb)     62    54   125
#  Downstream (1-2kb)    13    26    55
#  Downstream (2-3kb)    14    15    51
#  Exon                  82   159   386
#  Intron                84   128   319
#  Promoter (<=1kb)     993  1814  5393
#  Promoter (1-2kb)     584   954  2532
#  Promoter (2-3kb)     305   463  1162
#, ,  = TRUE
#                      down mixed    up
#  -                      3     0   270
#  Distal Intergenic      0     0     8
#  Downstream (<1kb)      0     0     0
#  Downstream (1-2kb)     0     0     0
#  Downstream (2-3kb)     0     0     0
#  Exon                   0     0     2
#  Intron                 0     0     3
#  Promoter (<=1kb)       0     0    64
#  Promoter (1-2kb)       0     0    17
#  Promoter (2-3kb)       0     0     8
save(df,combined,olapA,olapD,file="DBres_out.rdata")




q("no")

