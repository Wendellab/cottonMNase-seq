# diffACRs_csaw_AD1ref.r

# csaw workflow for ACR differential accessibility (DA) analysis of allopolyploidization
# Guanjing Hu
# huguanjing@gmail.com
# https://wendellab.github.io/cottonMNase-seq

# module load py-deeptools r/3.5.0-py2-ufvuwmm bedtools2
# cd /work/LAS/jfw-lab/hugj2006/cottonLeaf
# R
options(scipen=999)
library(csaw)
library(edgeR)
library(ggplot2)

# wrapper
mergeResults =function (ranges, tab, tol, get.best = TRUE, merge.args = list(),
    combine.args = list(), best.args = list())
{
    merged <- do.call(mergeWindows, c(list(ranges, tol = tol), merge.args))
    combined <- do.call(combineTests, c(list(merged$id, tab), combine.args))
    output <- DataFrame(regions = I(merged$region), combined = I(combined))
    if (get.best) {
        output$best <- do.call(getBestTest, c(list(merged$id,tab), best.args))
    }
    metadata(output)$id <- merged$id
    output
}
overlapResults = function (ranges, tab, regions, get.best = TRUE, overlap.args = list(),    combine.args = list(), best.args = list())
{
    olap <- do.call(findOverlaps, c(list(query = regions, subject = ranges),
        overlap.args))
    combined <- do.call(combineOverlaps, c(list(olap, tab), combine.args))
    output <- DataFrame(regions = I(regions), combined = I(combined))
    if (get.best) {
        output$best <- do.call(getBestOverlaps, c(list(olap,tab), best.args))
    }
    metadata(output)$overlaps <- olap
    output
}
# merged <- mergeResults(filtered.data, resDi$table, tol=100, merge.args=list(max.width=5000))
sumTab<-function(res1,res2,res3,med="")
{
    s1<-summary(decideTests(res1)) # FDR <0.05
    s2<-summary(decideTests(res2)) # FDR <0.05
    s3<-summary(decideTests(res3))
    tbl<-as.data.frame(cbind(s1,s2,s3))
    tbl$med<-med
    return(tbl)
}
# generate MA plots
plotRes<-function(resDi,resF,resM,resHr,resPr,n=10000,out="out.pdf"){
    require("ggplot2")
    require("gridExtra")
    resDi$table$sig = factor(decideTests(resDi), levels=c(-1,0,1))
    resF$table$sig  = factor(decideTests(resF),levels=c(-1,0,1))
    resM$table$sig  = factor(decideTests(resM),levels=c(-1,0,1))
    resHr$table$sig  = factor(decideTests(resHr),levels=c(-1,0,1))
    resPr$table$sig  = factor(decideTests(resPr),levels=c(-1,0,1))
    select = sample(1:nrow(resDi$table),n)
    cvalue<-c("red","black","red");names(cvalue)=c(-1,0,1)
    pdf(out)
    p1<-ggplot(data=data.frame(resDi$table[select,]), aes(x = logCPM, y = logFC, col = sig)) + geom_point() + scale_color_manual(values =cvalue[levels(droplevels(resDi$table[select,]$sig))]) + geom_smooth(inherit.aes=F, aes(x = logCPM, y = logFC), method = "loess") + geom_hline(yintercept = 0) + labs(col = NULL) + theme_bw()+ theme(legend.position = "none")
    p2<-ggplot(data=data.frame(resF$table[select,]), aes(x = logCPM, y = logFC, col = sig)) + geom_point() + scale_color_manual(values =cvalue[levels(droplevels(resF$table[select,]$sig))]) + geom_smooth(inherit.aes=F, aes(x = logCPM, y = logFC), method = "loess") + geom_hline(yintercept = 0) + labs(col = NULL) + theme_bw()+ theme(legend.position = "none")
    p3<-ggplot(data=data.frame(resM$table[select,]), aes(x = logCPM, y = logFC, col = sig)) + geom_point() + scale_color_manual(values =cvalue[levels(droplevels(resM$table[select,]$sig))]) + geom_smooth(inherit.aes=F, aes(x = logCPM, y = logFC), method = "loess") + geom_hline(yintercept = 0) + labs(col = NULL) + theme_bw()+ theme(legend.position = "none")
    p4<-ggplot(data=data.frame(resHr$table[select,]), aes(x = logCPM, y = logFC, col = sig)) + geom_point() + scale_color_manual(values =cvalue[levels(droplevels(resHr$table[select,]$sig))]) + geom_smooth(inherit.aes=F, aes(x = logCPM, y = logFC), method = "loess") + geom_hline(yintercept = 0) + labs(col = NULL) + theme_bw()+ theme(legend.position = "none")
    p5<-ggplot(data=data.frame(resPr$table[select,]), aes(x = logCPM, y = logFC, col = sig)) + geom_point() + scale_color_manual(values =cvalue[levels(droplevels(resPr$table[select,]$sig))]) + geom_smooth(inherit.aes=F, aes(x = logCPM, y = logFC), method = "loess") + geom_hline(yintercept = 0) + labs(col = NULL) + theme_bw()+ theme(legend.position = "none")
    grid.arrange(p1, p2, p3, p4,p5,ncol = 3, nrow = 3)
    dev.off()
}
########

# The input BAM files were generated by mapping all MNase-seq reads against the AD1 reference genome, properly paired restricted, mapping quality filtered, and sorted using script "runHisat2.sh".

#######################
## Convert BAM to BW ##
#######################
# sbatch runSh.slurm

###################################
## From sorted bam to DB results ##
###################################
setwd("/work/LAS/jfw-lab/hugj2006/cottonLeaf/Qregulation_diffACRs/AD1ref")

# specify paired-end BAMs from F1 and AD1
bam.files=grep("A6H_",list.files("mapping",patter="sort.bam$",full.names=T),invert=T,value=T)
# bam.files=grep("F|M",list.files("mapping",patter="sort.bam$",full.names=T),value=T)
df=data.frame(BAM=bam.files, genome=substring(bam.files,8+1,8+1),digestion=substring(bam.files,8+3,8+3))
df

# input identified ACRs
load("../../Qregulation3/ACRsC.rdata")->l;l
# test whether to seperately analyze subgenomes or together
peaks=list(A = ACR.AD1a, D=ACR.AD1d)

# separate A and D subgenomes for analysis
for(g in c("D","A"))
{
   ## 1. input sorted and indexed bam files
   use = df[df$genome=="F"|df$genome=="M"|df$genome==g,]
   use.chr <- c(paste0(g,"0", 1:9), paste0(g,10:13))
   print(use)
   print(use.chr)
   bams=as.character(use$BAM)
   # minimal MAPQ quality 20, paired-end
   param <- readParam(pe="both", restrict=use.chr);param
   
   ## 2.1. Count reads into ACRs
   peak.counts <- regionCounts(bams, peaks[[g]], param=param)
   # filter low abundance peaks
   peak.abundances <- aveLogCPM(asDGEList(peak.counts))
   # ......only use peaks logCPM > -3; few or no peaks should be removed; modify as desired
   keep <- peak.abundances > -3
   summary(keep)
   peak.counts.filt <- peak.counts[keep, ]
   
   ## 2.2. Count reads into 150 bp windows, based on fragment size
   win.data <- windowCounts(bams, ext=150, width=150, param=param)
   win.data
   head(assay(win.data))
   # Filtering out uninteresting regions.
   # simple restriction to filter window abundances at 5% lowe end
   abundances <- aveLogCPM(asDGEList(win.data))
   summary(abundances)
   keep.simple <- abundances > quantile(abundances,0.05)
   summary(keep.simple)
   # remove low variance
   logcounts <- cpm(asDGEList(win.data), log=TRUE)
   vars <- apply(logcounts, 1, var)
   keep.var <- vars > quantile(vars,0.25)
   summary(keep.var)
   # global enrichment to keep windows at least 1.5 fold of background signal
   bin.size <- 2000L
   binned <- windowCounts(bams, bin=TRUE, width=bin.size, param=param)
   filter.stat <- filterWindows(win.data, binned, type="global")
   min.fc=1.5
   pdf(paste0("checkBackground_",g,".pdf"))
   hist(filter.stat$back.abundances, xlab="Adjusted bin log-CPM", breaks=100, main="", col="grey80", xlim=c(min(filter.stat$back.abundances), 0))
   global.bg <- filter.stat$abundances - filter.stat$filter
   abline(v=global.bg[1], col="red", lwd=2)
   abline(v=global.bg[1]+log2(min.fc), col="blue", lwd=2)
   legend("topright", lwd=2, col=c('red', 'blue'),legend=c("Background", "Threshold"))
   dev.off()
   keep <- filter.stat$filter > log2(min.fc)
   summary(keep) # two stringent, losing too many data, not suitable for DNS-MNase-seq
   # filter used
   summary(keep.simple&keep.var)
   counts.local.filt <- win.data[keep.simple&keep.var,]
   
   ## 3. Calculating normalization factors.
   #  count BAM background bins (for TMM normalization)
   binned <- windowCounts(bams, bin=TRUE, width=10000, param=param)
   # --------------NORMALIZATION--------------------
   # method 1: ACR peaks only, TMM normalization based on binned counts
   peak.counts.tmm <- peak.counts.filt
   peak.counts.tmm <- normFactors(binned, se.out=peak.counts.tmm)
   # method 2: ACR peaks only, csaw loess-normalization
   peak.counts.loess <- peak.counts.filt
   peak.counts.loess <- normOffsets(peak.counts.loess, type="loess", se.out=TRUE)
   # from vignette: "For type="loess", a numeric matrix of the same dimensions as counts, containing the log-based offsets for use in GLM fitting.
   # method 3: csaw de novo peaks by local enrichment, TMM normalization based on binned counts
   counts.local.tmm <- counts.local.filt
   counts.local.tmm <- normFactors(binned, se.out=counts.local.tmm)
   # method 4: csaw de novo peaks by local enrichment, csaw loess-normalization
   counts.local.loess <- counts.local.filt
   counts.local.loess <- normOffsets(counts.local.loess, type="loess", se.out=TRUE)
   # from vignette: "For type="loess", a numeric matrix of the same dimensions as counts, containing the log-based offsets for use in GLM fitting."
   # --------------NORMALIZATION--------------------
   save(list=c("peak.counts.tmm","peak.counts.loess","counts.local.tmm","counts.local.loess"), file=paste0("DAnorm_",g,".rdata"))
   
   ## 4. DA analysis with 4 different methods
   for(med in c("peak.counts.tmm","peak.counts.loess","counts.local.tmm","counts.local.loess"))
   {
       # set working windows for the desired analysis
       working.windows <- get(med)
       y <- asDGEList(working.windows)
       sample<-gsub("_.*","",use$BAM)
       colnames(y$counts) <- sample
       rownames(y$samples) <- sample
       use$genome=gsub("A|D","P",use$genome)
       y$samples$group <- factor(paste0(use$genome,use$digestion))
       # setup design matrix; see edgeR manual for more information
       design <- model.matrix(~0+group, data=y$sample)
       # stabilize dispersion estimates with empirical bayes
       y <- estimateDisp(y, design)
       fit <- glmQLFit(y, design, robust=TRUE)
         # Estimate dispersion, plot e coefficient of biological variation (BCV) and quasi-likelihood (QL)dispersion
         # pdf(paste0("Dispersion_",g,".pdf"))
         # plotBCV(y)
         # plotQLDisp(fit)
         # dev.off()
       
       # DA analyses
       resDi <- glmQLFTest(fit, contrast=makeContrasts(groupPL-groupPH,levels=design))
       resF  <- glmQLFTest(fit, contrast=makeContrasts(groupFL-groupFH,levels=design))
       resM  <- glmQLFTest(fit, contrast=makeContrasts(groupML-groupMH,levels=design))
       resHr  <- glmQLFTest(fit, contrast=makeContrasts((groupFL-groupFH)-(groupPL-groupPH),levels=design))
       resPr  <- glmQLFTest(fit, contrast=makeContrasts((groupML-groupMH)-(groupFL-groupFH),levels=design))
       
       # MA plots and summary table
       # summary(decideTests(resDi)) # FDR <0.05
       tbl<-as.data.frame(cbind( summary(decideTests(resDi)), summary(decideTests(resF)), summary(decideTests(resM)), summary(decideTests(resHr)), summary(decideTests(resPr)) ))
       tbl$med<-med
       tbl$genome=g
       write.table(tbl,file=paste0("sigTable.",g,".",med,".txt"),sep="\t")
       plotRes(resDi,resF,resM,resHr,resPr,out=paste0("plotMA.",g,".",med,".pdf"))
       
       # for method 3 and 4, recalculate FDR by ACRs
       if(grepl("^counts",med))
       {
           for(i in c("resDi","resF","resM","resHr","resPr"))
           {
               print(i)
               res=get(i)
               olap <- overlapResults(working.windows, regions=peaks[[g]], tab=res$table)
               cx<-as.data.frame(table(olap$combined$direction,olap$combined$FDR<0.05))
               names(cx)<-c("direction","sig","number")
               cx$med<-med
               print(cx)
               cx$res<-i
               if(i=="resDi"){acx<-cx}else{acx<-rbind(acx,cx)}
               assign(i,olap)
           }
           write.table(acx,file=paste0("sigTable2.",g,".",med,".txt"),row.names=FALSE,sep="\t")
       }
      
      # save
       save(resDi,resF,resM,resHr,resPr, working.windows, file=paste0("DAres_",g,".",med,".rdata"))
    }
}
  

##########################################
## Compare DB results by 4 norm methods ##
##########################################
# put 4 method results together to inspect
library(reshape2)
fl<-list.files(pattern="sigTable[.].*peak")
for(f in fl){
    x<-read.table(f,header=T, sep="\t")
    y<-cbind(c("down","up"), x[c("Down","Up"),])
    names(y)=c("direction","P","F","M","Hr","Pr","med","genome")
    if(f==fl[1]){res<-y}else{res<-rbind(res,y)}
}
fl<-list.files(pattern="sigTable2")
for(f in fl){
    acx<-read.table(f,header=T, sep="\t")
    ss=dcast(acx,direction+sig+med~res,value.var="number")
    ss[is.na(ss)]=0
    #ss=cbind(acx[acx$res=="resDi",1:3],acx[acx$res=="resF",3],acx[acx$res=="resH",3:4])
    sss=ss[ss$sig&ss$direction!="mixed",c("direction","resDi","resF","resM","resHr","resPr","med")]
    sss$genome=unlist(strsplit(f,"[.]"))[2]
    names(sss)=c("direction","P","F","M","Hr","Pr","med","genome")
    res<-rbind(res,sss)
}

# Observed_up/ Expected_up
load("../../Qregulation3/ACRsC.rdata")->l;l;ACR.A2
exp=c(length(ACR.AD1a),length(ACR.AD1d))
names(exp)=c("A","D")
exp
#      A      D
#    260278 189068
res$expM=exp[as.character(res$genome)]
res$Pperc=res$P/res$expM
res$Fperc=res$F/res$expM
res$Mperc=res$M/res$expM
write.table(res, file="methodComp.AD1ref.txt",row.names=FALSE,sep="\t")

library(ggplot2)
library("gridExtra")
x<-read.table("methodComp.AD1ref.txt",head=T,sep="\t")
ss<- theme_bw()+ theme(legend.position = "none")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1))
p1<-ggplot(data=x,aes(x=med,y=P,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
p2<-ggplot(data=x,aes(x=med,y=F,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
p3<-ggplot(data=x,aes(x=med,y=M,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
p4<-ggplot(data=x,aes(x=med,y=Hr,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
p5<-ggplot(data=x,aes(x=med,y=Pr,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
p6<-ggplot(data=x,aes(x=med,y=Fperc,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
p7<-ggplot(data=x,aes(x=med,y=Pperc,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
p8<-ggplot(data=x,aes(x=med,y=Mperc,group=med,fill=direction))+geom_bar(stat="identity") + facet_grid(genome~.)
pdf("methodComp.AD1ref.pdf")
p1
p2
p3
grid.arrange(p1+ss, p2+ss, p3+ss, ncol = 3, nrow = 1)
p4
p5
grid.arrange(p4+ss, p5+ss, ncol = 3, nrow = 1)
p6
p7
p8
grid.arrange(p6+ss, p7+ss, p8+ss, ncol = 3, nrow = 1)
dev.off()
# based on p1~p3,  counts.local.tmm > counts.local.loess > peak.counts.tmm >> peak.counts.loess in finding ACRs
# Hr: all methods agree on that few changes (<30 ACRs) by hybridization, somehow more in D than A genome; more decrease then increase in accessbility

###########################################################
## De novo DA windows analysis: genome-wide and promoter ##
###########################################################
options(scipen=999)
library(csaw)
library(edgeR)
library(ggplot2)
library(GenomicFeatures)

setwd("/work/LAS/jfw-lab/hugj2006/cottonLeaf/Qregulation_diffACRs/AD1ref")

# specify paired-end BAMs from F1 and AD1
bam.files=grep("A6H_",list.files("mapping",pattern="sort.bam$",full.names=T),invert=T,value=T)
# bam.files=grep("F|M",list.files("mapping",patter="sort.bam$",full.names=T),value=T)
df=data.frame(BAM=bam.files, genome=substring(bam.files,8+1,8+1),digestion=substring(bam.files,8+3,8+3))
df

# input identified ACRs
load("../../Qregulation3/ACRsC.rdata")->l;l
# test whether to seperately analyze subgenomes or together
peaks=list(A = ACR.AD1a, D=ACR.AD1d)

# separate A and D subgenomes for counts.local.tmm analysis
for(g in c("A","D"))
{
    use = df[df$genome=="F"|df$genome=="M"|df$genome==g,]
    load( paste0("DAnorm_",g,".rdata") )

    # set working windows for the desired analysis
    med="counts.local.tmm"
    working.windows <- get(med)
    y <- asDGEList(working.windows)
    sample<-gsub("_.*","",use$BAM)
    colnames(y$counts) <- sample
    rownames(y$samples) <- sample
    use$genome=gsub("A|D","P",use$genome)
    y$samples$group <- factor(paste0(use$genome,use$digestion))
    # setup design matrix; see edgeR manual for more information
    design <- model.matrix(~0+group, data=y$sample)
    # stabilize dispersion estimates with empirical bayes
    y <- estimateDisp(y, design)
    fit <- glmQLFit(y, design, robust=TRUE)
      # Estimate dispersion, plot e coefficient of biological variation (BCV) and quasi-likelihood (QL)dispersion
      # pdf(paste0("Dispersion_",g,".pdf"))
      # plotBCV(y)
      # plotQLDisp(fit)
      # dev.off()
    
    # DA analyses
    resDi <- glmQLFTest(fit, contrast=makeContrasts(groupPL-groupPH,levels=design))
    resF  <- glmQLFTest(fit, contrast=makeContrasts(groupFL-groupFH,levels=design))
    resM  <- glmQLFTest(fit, contrast=makeContrasts(groupML-groupMH,levels=design))
    resHr  <- glmQLFTest(fit, contrast=makeContrasts((groupFL-groupFH)-(groupPL-groupPH),levels=design))
    resWr  <- glmQLFTest(fit, contrast=makeContrasts((groupML-groupMH)-(groupFL-groupFH),levels=design))
    resPr  <- glmQLFTest(fit, contrast=makeContrasts((groupML-groupMH)-(groupPL-groupPH),levels=design))
    #  save
    save(working.windows,resDi,resF,resM,resHr,resPr,resWr, file=paste0("res_",g,".",med,".rdata"))
}

### import genome annotation
txdb <- loadDb("../../refGenomes/txdb.AD1utx.sqlite")
# Gene region
gns= genes(txdb)
gns= gns[grep("scaffold|Contig",seqnames(gns),invert=T)]# 118590
quantile(width(gns))
gns.a = gns[grepl("A",seqnames(gns)),]
gns.d = gns[grepl("D",seqnames(gns)),]
gns=list(A=gns.a,D=gns.d)
# get promoter
getTSS=function(txdb, include=NULL, exclude.pattern=NULL, be=1000, af=1000){
    tss =  genes(txdb)
    if(!is.null(exclude.pattern)) {tss = tss[grep(exclude.pattern,tss$gene_id,invert=T)]}
    if(!is.null(include)) {tss = tss[tss$gene_id %in% include]}
    # +
    end(tss[strand(tss)=="+",])  =start(tss[strand(tss)=="+",])+af
    start(tss[strand(tss)=="+",])  =start(tss[strand(tss)=="+",])-be
    # -
    start(tss[strand(tss)=="-",])=end(tss[strand(tss)=="-",])-af
    end(tss[strand(tss)=="-",])=end(tss[strand(tss)=="-",])+be
    # remove duplicated TSSes ie alternative transcripts
    # this keeps the first instance and removes duplicates
    tss=tss[!duplicated(tss),]
    seqlevels(tss)=unique(as.character(seqnames(tss)))
    return(tss)
}
#
pms=  getTSS(txdb, exclude.pattern="Gohir.1Z", be=1000, af=0)
pms.a = pms[grep("A",seqnames(pms))] #36116
pms.d = pms[grep("D",seqnames(pms))] #38784
pms1k=list(A=pms.a,D=pms.d)
#
pms=  getTSS(txdb, exclude.pattern="Gohir.1Z", be=2000, af=0)
pms.a = pms[grep("A",seqnames(pms))] #36116
pms.d = pms[grep("D",seqnames(pms))] #38784
pms2k=list(A=pms.a,D=pms.d)
#
pms=  getTSS(txdb, exclude.pattern="Gohir.1Z", be=500, af=0)
pms.a = pms[grep("A",seqnames(pms))] #36116
pms.d = pms[grep("D",seqnames(pms))] #38784
pms500=list(A=pms.a,D=pms.d)
#
pms=  getTSS(txdb, exclude.pattern="Gohir.1Z", be=300, af=0)
pms.a = pms[grep("A",seqnames(pms))] #36116
pms.d = pms[grep("D",seqnames(pms))] #38784
pms300=list(A=pms.a,D=pms.d)

# Examine results
sigRes=function(res, label=NULL){
    require(reshape2)
    names(res) # "regions"  "combined" "best"
    res0=data.frame(Var1=c("sigN","sigBp","sigN","sigBp"),Var2=c("up","up","down","down"),value=0)
    # combined results
    sig=which(res$combined$FDR<0.05)
    if(length(sig)>0){
        sigN=tapply(width(res$regions[sig]),res$combined$direction[sig], FUN=length)
        sigBp=tapply(width(res$regions[sig]),res$combined$direction[sig], FUN=sum)
        Cres=melt(rbind(sigN,sigBp))
    }else{ Cres= res0}
    Cres$FDR="combined"
    # best results
    sig=which(res$best$FDR<0.05)
    if(length(sig)>0){
        res$best$direction = ifelse(res$best$logFC>0, "up","down")
        sigN=tapply(width(res$regions[sig]),res$best$direction[sig], FUN=length)
        sigBp=tapply(width(res$regions[sig]),res$best$direction[sig], FUN=sum)
        Bres=melt(rbind(sigN,sigBp))
    }else{ Bres= res0}
    Bres$FDR="best"
    lres=rbind(Cres,Bres)
    if(!is.na(label)){lres$label=label}
    return(lres)
}
#
sigRes0=function(res, label=NULL,fdr=0.1){
    require(reshape2)
    names(res) # "regions"  "combined" "best"
    res0=data.frame(Var1=c("sigN","sigBp","sigN","sigBp"),Var2=c("up","up","down","down"),value=0)
    # combined results
    sig=which(res$combined$FDR<fdr)
    if(length(sig)>0){
        sigN=tapply(width(res$regions[sig]),res$combined$direction[sig], FUN=length)
        sigBp=tapply(width(res$regions[sig]),res$combined$direction[sig], FUN=sum)
        Cres=melt(rbind(sigN,sigBp))
    }else{ Cres= res0}
    Cres$FDR="combined"
    # best results
    sig=which(res$best$FDR<fdr)
    if(length(sig)>0){
        res$best$direction = ifelse(res$best$logFC>0, "up","down")
        sigN=tapply(width(res$regions[sig]),res$best$direction[sig], FUN=length)
        sigBp=tapply(width(res$regions[sig]),res$best$direction[sig], FUN=sum)
        Bres=melt(rbind(sigN,sigBp))
    }else{ Bres= res0}
    Bres$FDR="best"
    lres=rbind(Cres,Bres)
    if(!is.na(label)){lres$label=label}
    return(lres)
}

for(g in c("A","D"))
{
    # get working windows for the desired analysis
    med="counts.local.tmm"
    load( paste0("res_",g,".",med,".rdata"))
    
    for(i in c("resDi","resF","resM","resHr","resWr","resPr"))
        {
            print(i)
            res=get(i)
            # merging windows, Correcting for multiple testing.
            merged <- mergeResults(working.windows, res$table, tol=200L)
            # overlap to ACRs, Correcting for multiple testing.
            olACR <- overlapResults(working.windows, tab=res$table, regions=peaks[[g]])
            # overlap to promoters, Correcting for multiple testing.
            olG <- overlapResults(working.windows, tab=res$table, regions=gns[[g]])
            olP300 <- overlapResults(working.windows, tab=res$table, regions=pms300[[g]])
            olP500 <- overlapResults(working.windows, tab=res$table, regions=pms500[[g]])
            olP1k <- overlapResults(working.windows, tab=res$table, regions=pms1k[[g]])
            olP2k <- overlapResults(working.windows, tab=res$table, regions=pms2k[[g]])
            sr<-rbind(sigRes(merged,"SlidingW"), sigRes(olACR,"ACR"),sigRes(olG,"Gene"), sigRes(olP300,"Promoter300"), sigRes(olP500,"Promoter500"), sigRes(olP1k,"Promoter1k"), sigRes(olP2k,"Promoter2k"))
            sr$test=i
            sr$genome=g
            print(sr)
            # print(sumRes)
            if(g=="A"&i=="resDi"){sumtbl=sr}else{sumtbl=rbind(sumtbl,sr)}
            #save(merged, olACR, olG, olP300,olP1k, olP2k, file=paste0(i,"_",g,".",med,".rdata"))
        }
}
write.table(sumtbl,file="resNnBp.AD1ref.txt",row.names=FALSE,sep="\t")
sumtbl

## Plot results
x<-read.table("resNnBp.AD1ref.txt",header=T,sep="\t")
Pr<-x[x$test=="resPr"&x$Var1=="sigBp"&x$label=="SlidingW"&x$FDR=="combined",]
Hr<-x[x$test=="resHr"&x$Var1=="sigBp"&x$label=="SlidingW"&x$FDR=="combined",]
Pr$fold = Pr$value/Hr$value
# plot effect
library(ggplot2)
pdf("resNnBp.AD1ref.pdf")
ss<- theme_bw()+ theme(legend.position = "right")+ theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1))
# resHr vs resPr, separate N and Bp.
ggplot(data=x[x$test%in%c("resHr","resPr","resWr")&x$Var1=="sigN",],aes(x=test,y=value,group=test,fill=Var2))+geom_bar(stat="identity")+ facet_grid(genome~label+FDR)+ss +   xlab("") + ylab("Number")
ggplot(data=x[x$test%in%c("resHr","resPr","resWr")&x$Var1=="sigBp",],aes(x=test,y=value,group=test,fill=Var2))+geom_bar(stat="identity")+ facet_grid(genome~label+FDR)+ss+   xlab("") + ylab("Size (bp)")
ggplot(data=x[x$test%in%c("resHr","resPr","resWr")&x$Var1=="sigN"&grepl("Promoter",x$label),],aes(x=test,y=value,group=test,fill=Var2))+geom_bar(stat="identity")+ facet_grid(genome~label+FDR)+ss+   xlab("") + ylab("Number")
ggplot(data=x[x$test%in%c("resHr","resPr","resWr")&x$Var1=="sigBp"&grepl("Promoter",x$label),],aes(x=test,y=value,group=test,fill=Var2))+geom_bar(stat="identity")+ facet_grid(genome~label+FDR)+ss+   xlab("") + ylab("Size (bp)")
# resDi, F, M
ggplot(data=x[x$test%in%c("resDi","resF","resM")&x$Var1=="sigN",], aes(x=test,y=value,group=test,fill=Var2))+geom_bar(stat="identity")+ facet_grid(genome~label+FDR)+ss+   xlab("") + ylab("Number")
ggplot(data=x[x$test%in%c("resDi","resF","resM")&x$Var1=="sigBp",], aes(x=test,y=value,group=test,fill=Var2))+geom_bar(stat="identity")+ facet_grid(genome~label+FDR)+ss+   xlab("") + ylab("Size (bp)")
dev.off()
# CONCLUSION: 1.Pr > Hr increased accessibility for ACR, genome-wid, and 1kb promoter, what about gene body and other locations, eg. TE? 2. best and combined results are quite consistent
# Under 400 merged regions with DA, quite stringent, not sure if worth pursuing details


## Annotate DA merged results ##
################################
# merged - annotate genomic distribution, ChIPseeker??
# ACR
library(ChIPseeker) # module load r-udunits2
library(gridExtra)
# summary
getPeakInfo = function(peakAnno){
    anno =peakAnno@anno
    catLevel = c( "Promoter (<=1kb)", "Promoter (1-2kb)", "Promoter (2-3kb)", "Downstream (<1kb)", "Downstream (1-2kb)", "Downstream (2-3kb)", "Exon", "Intron", "Distal Intergenic" , "5' UTR","3' UTR")
    direction=factor(anno$direction)
    category = factor(anno$annotation2,levels = catLevel)
    nn<-aggregate(rep(1,length(anno)),list(category,direction),sum)
    names(nn)<-c("Feature","direction","Number")
    ss<-aggregate(width(anno),list(category,direction),sum)
    names(ss)<-c("Feature","direction","RegionSize")
    df=data.frame(Feature=rep(catLevel,each=2), direction=c("up","down"))
    df=merge(merge(df,nn,all.x=T),ss,all.x=T)
    #df =data.frame(Feature=catLevel, Number = tapply(width(anno),list(category,direction),sum), RegionSize = tapply(rep(1,length(category)),category,sum) )
    rownames(df)=NULL
    df[is.na(df)]=0
    df$NumberPerc = df$Number/sum(df$Number)
    df$RegionSizePerc = df$RegionSize/sum(df$RegionSize)
    return(df)
}
dflist2df = function(df.list)
{
    samples = names(df.list)
    df = df.list[[1]]
    df$Sample=samples[1]
    for(i in 2:length(samples)){
        x = df.list[[i]]
        x$Sample = samples[i]
        df = rbind(df, x)
    }
    # levels(df$Feature)=c( "Promoter (<=1kb)", "Promoter (1-2kb)", "Promoter (2-3kb)", "Exon", "Intron", "Downstream (<=300)","Distal Intergenic" )
    # df$Sample=factor(df$Sample, levels=c("A2","D5","F1.At","F1.Dt","AD1.At","AD1.Dt"))
    return(df)
}
plotPeakInfo = function(df, y=c("Number", "RegionSize", "NumberPerc", "RegionSizePerc") ,xlab="", ylab="Peak region (bp)", title="")
{
    p <- ggplot(df, aes_string(x = "Sample", fill = "Feature", y = y)) + geom_bar(stat="identity") + facet_wrap(~direction)
    p <- p + ylab(ylab) + xlab(xlab) + ggtitle(title)
    p <- p + coord_flip() + theme_bw()
    ff<-c("Promoter (2-3kb)","Promoter (1-2kb)","Promoter (<=1kb)","Intron","Exon", "Downstream (2-3kb)","Downstream (1-2kb)","Downstream (<1kb)","Distal Intergenic")
    #ff<-c( "Distal Intergenic", "Downstream (<1kb)", "Downstream (1-2kb)", "Downstream (2-3kb)", "Exon",  "Intron","Promoter (<=1kb)","Promoter (1-2kb)","Promoter (2-3kb)")
    p <- p+scale_fill_manual(values=rev(getCols(9)[match(rev(levels(factor(df$Feature))),ff)]), guide=guide_legend(reverse=T))
    return(p)
    print(p)
}
getCols <- function(n) {
    col <- c("#8dd3c7", "#ffffb3", "#bebada",
    "#fb8072", "#80b1d3", "#fdb462",
    "#b3de69", "#fccde5", "#d9d9d9",
    "#bc80bd", "#ccebc5", "#ffed6f")
    
    col2 <- c("#1f78b4", "#ffff33", "#c2a5cf",
    "#ff7f00", "#810f7c", "#a6cee3",
    "#006d2c", "#4d4d4d", "#8c510a",
    "#d73027", "#78c679", "#7f0000",
    "#41b6c4", "#e7298a", "#54278f")
    
    col3 <- c("#a6cee3", "#1f78b4", "#b2df8a",
    "#33a02c", "#fb9a99", "#e31a1c",
    "#fdbf6f", "#ff7f00", "#cab2d6",
    "#6a3d9a", "#ffff99", "#b15928")
    
    ## colorRampPalette(brewer.pal(12, "Set3"))(n)
    colorRampPalette(col3)(n)
}
txdb <- loadDb("../../refGenomes/txdb.AD1utx.sqlite")
anL=list()
for(g in c("A","D"))
{
    # get working windows for the desired analysis
    med="counts.local.tmm"
    load( paste0("res_",g,".",med,".rdata"))
    for(i in c("resDi","resF","resM","resHr","resWr","resPr"))
        {
            print(i)
            res=get(i)
            # merging windows, Correcting for multiple testing.
            merged <- mergeResults(working.windows, res$table, tol=200L)
            gr<-merged$regions
            gr$FDR<-merged$combined$FDR
            gr$direction<-merged$combined$direction
            gr<-gr[gr$FDR<0.05]
            # ChiPseeker
            an = annotatePeak(gr, TxDb=txdb, tssRegion=c(-3000, 3000), verbose=FALSE,genomicAnnotationPriority = c("Promoter","Exon", "Intron", "Downstream", "Intergenic","5UTR", "3UTR"))
            an@anno$annotation2=gsub("on .*","on",an@anno$annotation)
            print(an)
            anL[[paste0(i,g)]]<-an
        }
}
# plot summary
df = dflist2df(lapply(anL, getPeakInfo))
df=df[df$Number>0,]
df$Test<-"between"
df$Test[df$Sample%in%c("resDiA","resDiD","resFA","resFD","resMA","resMD")]="within"
df$Feature= factor(df$Feature,levels=)
save(anL, df, file="merged.annotation.rdata")
#

pdf("merged.annotation.pdf")
print(plotAnnoBar(anL, title="Footprints Distribution"))
p1<-plotPeakInfo(df[df$Test=="within",], y="RegionSize",ylab ="Peak region (bp)")
p2<-plotPeakInfo(df[df$Test=="within",], y="RegionSizePerc",ylab ="Peak region %")
p3<-plotPeakInfo(df[df$Test=="within",], y="Number",ylab ="Peak number")
p4<-plotPeakInfo(df[df$Test=="within",], y="NumberPerc",ylab ="Peak number %")
grid.arrange(p4+theme(legend.position="none"),p1+theme(legend.position="none"),p3+theme(legend.position="none"),p2+theme(legend.position="none"),nrow=2,ncol=2)
p1;p2;p3;p4
p1<-plotPeakInfo(df[df$Test=="between",], y="RegionSize",ylab ="Peak region (bp)")
p2<-plotPeakInfo(df[df$Test=="between",], y="RegionSizePerc",ylab ="Peak region %")
p3<-plotPeakInfo(df[df$Test=="between",], y="Number",ylab ="Peak number")
p4<-plotPeakInfo(df[df$Test=="between",], y="NumberPerc",ylab ="Peak number %")
grid.arrange(p4+theme(legend.position="none"),p1+theme(legend.position="none"),p3+theme(legend.position="none"),p2+theme(legend.position="none"),nrow=2,ncol=2)
p1;p2;p3;p4
dev.off()

con<- read.table("Qregulation4/conserved.regPattern.txt",header=T, sep="\t")
#con<- read.table("~/Nutstore Files/GHuLab-Me/2.Projects/Project_MNase-seq/7.Questions/Qregulation4/conserved.regPattern.txt",header=T, sep="\t")

# For genes with increased DA within 1kb promoter by genome doubling, do they show any Wr expression patterns??? NO, most Wr=0. Too few genes with DA
# At: DA changes by doubling is not associated with expression Wr
con[as.character(con$V3) %in% as.character(anL$resWrA@anno$geneId[anL$resWrA@anno$annotation=="Promoter (<=1kb)" & anL$resWrA@anno$direction=="up"]),]
con[as.character(con$V3) %in% as.character(anL$resWrA@anno$geneId[anL$resWrA@anno$annotation=="Promoter (<=1kb)" & anL$resWrA@anno$direction=="down"]),]
# Dt: DA changes by doubling is not associated with expression Wr
con[as.character(con$V4) %in% as.character(anL$resWrD@anno$geneId[anL$resWrD@anno$annotation=="Promoter (<=1kb)" & anL$resWrD@anno$direction=="up"]),]
con[as.character(con$V4) %in% as.character(anL$resWrD@anno$geneId[anL$resWrD@anno$annotation=="Promoter (<=1kb)" & anL$resWrD@anno$direction=="down"]),]

### Should I focus on promoter changes




## Focusing on sliding windows
# resHr vs resPr, separate N and Bp.
x<-read.table("resNnBp.AD1ref.txt",header=T,sep="\t")
y<-x[x$test%in%c("resHr","resPr")&x$Var1=="sigBp"&x$label=="SlidingW",]
y$reference<-"AD1"
aggregate(value~test+Var2+FDR,data=y,sum)
#    test  Var2      FDR   value
# 1 resHr  down     best  214600
# 2 resPr  down     best  778100
# 3 resHr    up     best  294350
# 4 resPr    up     best 3142900
# 5 resHr  down combined  234150
# 6 resPr  down combined  740450
# 7 resPr mixed combined   52050
# 8 resHr    up combined  304350
# 9 resPr    up combined 3301250

x<-read.table("resNnBp.F1ref.txt",header=T,sep="\t")
z<-x[x$test%in%c("resHr","resPr")&x$Var1=="sigBp"&x$label=="SlidingW",]
z$reference<-"A2+D5"
aggregate(value~test+Var2+FDR,data=z,sum)
#   test  Var2      FDR   value
# 1 resHr  down     best  131600
# 2 resPr  down     best  434500
# 3 resHr    up     best    4800
# 4 resPr    up     best 4193650
# 5 resHr  down combined  137850
# 6 resPr  down combined  453400
# 7 resPr mixed combined    9300
# 8 resHr    up combined   16300
# 9 resPr    up combined 4355250

xx<-rbind(y,z)
names()
pdf("resBp.impact.pdf")
ggplot(data=xx,aes(x=test,y=value,group=test,fill=Var2))+geom_bar(stat="identity")+ facet_grid(genome~reference+FDR)+ss
dev.off()

